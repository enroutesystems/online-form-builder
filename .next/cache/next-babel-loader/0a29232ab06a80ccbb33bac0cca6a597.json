{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { firestore } from '../firebaseConfig';\nimport questionTypes from './questionTypes';\nimport collections from './collections';\n\nconst getOptionAnswers = async questionId => {\n  const arrayOptions = [];\n  const snapshot = await firestore.collection(collections.optionAnswers).where('questionId', '==', questionId).get();\n  snapshot.forEach(doc => arrayOptions.push({\n    text: doc.data().text,\n    optionAnswerId: doc.id\n  }));\n  return arrayOptions;\n};\n\nconst getQuestions = async formId => {\n  let snapshotQuestions;\n  let tempArrayQuestions = [];\n  let arrayQuestions = [];\n  snapshotQuestions = await firestore.collection(collections.questions).where('formId', '==', formId).get();\n  snapshotQuestions.forEach(doc => tempArrayQuestions.push(doc));\n\n  for (let doc of tempArrayQuestions) {\n    let oQuestion = _objectSpread({}, doc.data());\n\n    if (oQuestion.type === questionTypes.multiOptions) oQuestion.options = await getOptionAnswers(doc.id);\n    delete oQuestion.formId;\n    arrayQuestions.push(_objectSpread(_objectSpread({}, oQuestion), {}, {\n      questionId: doc.id\n    }));\n  }\n\n  return arrayQuestions;\n};\n\nexport const getForms = async (uid, formId) => {\n  let result = [];\n  let snapshotForm;\n  let document;\n  if (uid && formId) return {\n    message: 'You must provide uid or formId but not both.'\n  };\n  if (!uid && !formId) return {\n    message: 'You must provide uid or formId'\n  };\n\n  try {\n    if (formId) {\n      document = await firestore.collection(collections.forms).doc(formId).get();\n      result = document.data();\n      result.formId = document.id;\n      result.questions = await getQuestions(formId);\n    }\n\n    if (uid) {\n      /*this will store forms' snapshot temporarily, because asynchronous functions \n      doesn't executes correctly within forEach method of snapshot.*/\n      let tempForms = [];\n      snapshotForm = await firestore.collection(collections.forms).where('uid', '==', uid).get();\n      snapshotForm.forEach(doc => {\n        tempForms.push({\n          id: doc.id,\n          data: doc.data()\n        });\n      });\n\n      for (let form of tempForms) {\n        form.data.formId = form.id;\n        form.data.questions = await getQuestions(form.id);\n        result.push(form.data);\n      }\n    }\n  } catch (err) {\n    console.log('ERROR', err);\n  }\n\n  return result;\n};\n/**\n * Registers each option of options array into database\n * @param {string} questionId \n * @param {array} options \n */\n\nconst createOptionAnswers = async (questionId, options) => {\n  for (let text of options) {\n    try {\n      await firestore.collection(collections.optionAnswers).add({\n        questionId,\n        text\n      });\n    } catch {\n      return {\n        ok: false,\n        message: 'Error while trying to save option answers'\n      };\n    }\n  }\n\n  return {\n    ok: true\n  };\n};\n/**\n * Validates if the question object has the necessary properties\n * @param {object} question \n */\n\n\nconst validateQuestion = question => {\n  if (!question) return {\n    ok: false,\n    message: 'Form must have at least one question'\n  };\n  if (!question.type || !question.text) return {\n    ok: false,\n    message: 'Question text and type must be provided'\n  }; //if question type is multi-options\n\n  if (question.type === questionTypes.multiOptions) {\n    //if question options doesn't have at least 2 options\n    if (!question.options || !question.options instanceof Array || question.options.length <= 1) return {\n      ok: false,\n      message: 'Question of type \"multi-options\" must have at least two option'\n    };\n  }\n\n  return {\n    ok: true\n  };\n};\n/**\n * Registers the question into database\n * @param {string} formId \n * @param {Number} number \n * @param {object} question \n */\n\n\nconst createQuestion = async (formId, number, question) => {\n  const validation = validateQuestion(question);\n  if (!validation.ok) return {\n    message: validation.message\n  };\n  let newQuestion;\n\n  try {\n    newQuestion = await firestore.collection(collections.questions).doc();\n    await newQuestion.set({\n      formId,\n      number,\n      type: question.type,\n      text: question.text\n    });\n\n    if (question.type === questionTypes.multiOptions) {\n      const resultOptionAnswers = await createOptionAnswers(newQuestion.id, question.options);\n      if (!resultOptionAnswers.ok) return {\n        message: resultOptionAnswers.message\n      };\n    }\n  } catch {\n    return {\n      message: 'Error while trying to save questions data'\n    };\n  }\n\n  return await (await newQuestion.get()).data();\n};\n/**\n * Deletes selected form and it's questions and option answes\n */\n\n\nconst deleteForm = async formId => {\n  const tempMultiOptionsQuestions = [];\n  const batch = firestore.batch(); //get questions with multi-options type \n\n  const snapshotMultiOptionsQuestions = await firestore.collection(collections.questions).where('formId', '==', formId).where('type', '==', questionTypes.multiOptions).get(); //each multi-optios questions is pushed to array\n\n  snapshotMultiOptionsQuestions.forEach(doc => tempMultiOptionsQuestions.push(doc)); //for each question with multi-options type\n\n  for (let doc of tempMultiOptionsQuestions) {\n    //get option answers for current question\n    const snapshotOptionAnswers = await firestore.collection(collections.optionAnswers).where('questionId', '==', doc.id); //delete each option of current quiestion\n\n    snapshotOptionAnswers.forEach(doc => batch.delete(doc.ref));\n  }\n\n  const snapshotQuestions = await firestore.collection(collections.questions).where('formId', '==', formId).get();\n  snapshotQuestions.forEach(doc => batch.delete(doc.ref));\n  await firestore.collection('forms').doc(formId).delete();\n  await batch.commit();\n};\n/**arrayDate = [year, monthIndex, day, *hour, *minutes, *seconds] \n * hour, minutes and seconds are optionals\n*/\n\n\nexport const createForm = async (uid, formName, isPublic, limitResponses, arrayDate, arrayTime, questions) => {\n  if (!uid) return {\n    message: 'User ID is required'\n  };\n  if (!formName) return {\n    message: 'Form name is required'\n  };\n  const data = {\n    uid,\n    formName,\n    isPublic: isPublic == 'true'\n  };\n  if (limitResponses) data.limitResponses = limitResponses;\n\n  if (arrayDate.length > 0) {\n    const arrayDateFinal = []; //if arrayDate has at least one not undefined value, then it's pushed to arrayDateFinal\n\n    const dateExists = arrayDate.some(value => value !== undefined);\n    const timeExists = arrayTime.some(value => value !== undefined);\n\n    if (dateExists) {\n      arrayDateFinal.push(...arrayDate); //if arrayTime has at least one not undefined value, then it's pushed to arrayDateFinal\n\n      if (timeExists) arrayDateFinal.push(...arrayTime);\n    } else {\n      if (timeExists) return {\n        message: 'Invalid Date'\n      };\n    }\n\n    data.endDate = new Date(...arrayDateFinal).toLocaleString(); //if endDate is not a date\n\n    if (data.endDate == 'Invalid Date') return {\n      message: 'Invalid Date'\n    };\n  }\n\n  let result;\n\n  try {\n    result = await firestore.collection(collections.forms).add(data);\n  } catch {\n    return {\n      message: 'Error while trying to save form data'\n    };\n  }\n\n  const form = await result.get();\n\n  for (let index in questions) {\n    const questionResult = await createQuestion(form.id, parseInt(index) + 1, questions[index]); //if there's an error registering questions in database, form and it's questions are deleted\n\n    if (questionResult.message) {\n      await deleteForm(form.id);\n      return {\n        message: questionResult.message\n      };\n    }\n  }\n\n  return await form.data();\n};","map":null,"metadata":{},"sourceType":"module"}