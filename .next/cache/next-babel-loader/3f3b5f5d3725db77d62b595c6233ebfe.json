{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { firestore } from '../firebaseConfig';\nimport collections from './collections';\nexport const getResponses = async (formId, uid) => {\n  const arrayQuestions = [];\n  const arrayResponses = [];\n  const snapshotQuestions = await firestore.collection(collections.questions).where('formId', '==', formId).get();\n  snapshotQuestions.forEach(doc => arrayQuestions.push(doc.id));\n\n  for (let questionId of arrayQuestions) {\n    let snapshotUserResponses = firestore.collection(collections.userResponses).where('questionId', '==', questionId);\n    if (uid) snapshotUserResponses = await snapshotUserResponses.where('uid', '==', uid).get();else snapshotUserResponses = await snapshotUserResponses.get();\n    snapshotUserResponses.forEach(doc => arrayResponses.push(doc.data()));\n  }\n\n  return {\n    formId,\n    responses: arrayResponses\n  };\n};\n/**\n * Validates if sent answers have the correct format\n * @param {string[]} answers \n */\n\nconst validateAnswers = answers => {\n  for (let answer of answers) {\n    if (!answer.questionId) return {\n      message: 'Every answer must have a questionId'\n    }; //checks if answer contains response or optionAnswerId but not both\n\n    if (answer.response || answer.optionAnswerId) {\n      if (answer.response && answer.optionAnswerId) return {\n        message: 'No answer should contain both response and optionAnswerId'\n      };\n    } else return {\n      message: 'Every answer must have a response or optionAnswerId'\n    };\n  }\n\n  return {\n    ok: true\n  };\n};\n/**\n * \n * @param {object} form \n * @param {string} formId \n * @param {string} uid \n */\n\n\nconst isAllowedToAnswer = async (form, formId, uid) => {\n  let oAllowedUser = {};\n\n  if (!form.isPublic) {\n    if (!uid) return {\n      message: 'uid is required to fill this form'\n    };\n    const snapshotAllowedUsers = await firestore.collection(collections.allowedUsers).where('formId', '==', formId).where('uid', '==', uid).get();\n    snapshotAllowedUsers.forEach(doc => oAllowedUser = doc.data());\n    if (oAllowedUser.uid === uid) return {\n      ok: true\n    };else return {\n      message: 'User is not allowed to fill this form'\n    };\n  }\n};\n/**\n * Deletes all the responses in form made by the user\n * @param {string} uid \n * @param {object[]} answers \n */\n\n\nconst deleteUserResponse = async (uid, answers) => {\n  const batch = firestore.batch();\n\n  for (let answer of answers) {\n    const snapshotUserResponse = await firestore.collection(collections.userResponses).where('questionId', '==', answer.questionId).where('uid', '==', uid).get();\n    snapshotUserResponse.forEach(doc => {\n      console.log('data', doc.data());\n      batch.delete(doc.ref);\n    });\n  }\n\n  await batch.commit();\n};\n/**\n * Saves the answers of a specific form into database\n * @param {string} uid \n * @param {string[]} answers \n */\n\n\nexport const sendAnswers = async (formId, uid, answers) => {\n  const form = await (await firestore.collection(collections.forms).doc(formId).get()).data();\n  const validation = validateAnswers(answers);\n  const allowedUser = await isAllowedToAnswer(form, formId, uid);\n  if (validation.message) return {\n    message: validation.message\n  };\n  if (allowedUser.message) return {\n    message: allowedUser.message\n  };\n\n  for (let answer of answers) {\n    try {\n      await firestore.collection(collections.userResponses).add(_objectSpread({\n        uid\n      }, answer));\n    } catch {\n      await deleteUserResponse(uid, answers);\n      return {\n        message: 'Error while trying to save response into database'\n      };\n    }\n  }\n\n  return {\n    ok: true\n  };\n};","map":null,"metadata":{},"sourceType":"module"}